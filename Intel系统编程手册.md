## 2.1 系统级架构概览

系统架构包含:

- 寄存器
- 数据结构
- 系统操作专用指令(内存管理/中断/异常处理/任务管理/多处理器控制)

如下图所示:

![](/images/System-Level&#32;Registers&#32;and&#32;Data&#32;Structures.png)

每个段描述符都有一个相关的**段选择子(segment selector)**. 

要想访问某个段中的某个字节,必须要提供一个段选择子和一个偏移量.

1. 通过段选择子访问GDT/LDT,获取段描述符.
2. 系统取 MAX{访问来源的 CPL,段选择子卸载的 RPL},与目标段的权限比较,大于则允许访问.
3. 通过段描述符获取目标段的基址.
4. 基址加上偏移量,就是我们要的地址.

图中的实线箭头代表线性地址,虚线代表一个段选择器,点号箭头代表物理地址.简便起见,很多段选择子都被图示为直接指向一个段.实际上从段选择子是通过一个 GDT/LDT指向相关段.

GDT 本身的地址储存在 GDT 寄存器中(即 GDTR).LDT 的地址保存在 LDT寄存器(LDTR) 中.

软件如何使用段选择子? 段选择子向软件提供了什么信息?

- GDT/LDT 在哪?(段描述符的索引)
- 是GDT 还是 LDT? (T flag)
- 权限是什么?




段选择子包含软件访问 GDT/LDT 时所需要的索引

## Chapter 2.1.1 全局/本地描述符表

当系统运行在保护模式时,所有对内存的访问都要经过 GDT 或 LDT(可选).这些表的条目叫做段描述符(segment descriptor).段描述符提供了段基址,和段访问权限/类型/使用信息.



## 3.1 内存管理概览

32 位架构内存管理分两部分: 分段和分页.

分段: 把独立的代码,数据,和栈模块联系起来,这样同一个处理器即可处理多任务.

分页: "按需分页"的虚拟内存系统,程序的执行环境被按需映射至物理内存.分页也可以被用来提供多任务的隔离机制.当操作系统处于保护模式时,有些格式的分段是必需的. **分段是不可以去使能的**, 而分页是可选的.

这两种机制可以被配置为:简单的单任务系统,多任务系统,(使用共享内存的)多处理器系统.

如下图,分段机制可以吧处理器的可寻址空间(即**线性地址空间**)分割为小块的被保护的地址(即**segment**).segment 可以用来保存某个程序的code,data,和 stack,或者维护系统的数据结构,如 TSS 或 LDT 等. 如果单个处理器运行多于一个程序,那么每个程序可以被分配给它自己的 segment,然后处理器强制限制这些 segment的边界,使得单个程序无法写入其他程序的 segment,以保证每个程序都不会影响到其他程序.每个段可以有自己的类别,这样对于某种特定类的段的操作就可以有所限制.

系统中所有的segment 都被包含在 cpu 的线性地址空间站中.

![](/images/Segmentation&#32;and&#32;Paging.png)

## 6.10 中断描述符表(IDT)

抽象表示:

中断向量(地址索引) | 门描述符(8bit)
---|---|
0 | gate descriptor1
1 | gate descriptor2
...|...
255|gate descriptor255

图示:

![](/images/IDRT&IDT.jpg)

门描述符具体可分为三类:

- 任务切换门描述符(Task-gate descriptor)
- 中断门描述符(Interrupt-gate descriptor)
- 陷阱门描述符(Trap-gate descriptor)

任务门在 IDT 中与在 GDT/LDT 中相同.它维护着段选择子,用于寻址处理异常/中断的任务切换段(TSS).不需要偏移量这个参数.

中断门和陷阱门与调用们很相似.它们维护着一个 far pointer,也就是段选择子和偏移量,用于寻址异常处理代码.不同之处在于 IF 标志位.

![](/images/IDT&#32;Gate&#32;Descriptors.jpg)

## 6.12 处理器处理异常的方法

当异常发生时,处理器用中断向量作为索引值,访问 IDT.如果索引值指向中断们或陷阱门,那么处理器的处理方式与调用门很像.如果指向任务切换们,那么处理器切换至对应的异常处理器.

### 6.12.1 异常处理流程

当处理器处理异常过程时:

1. 如果处理流程在特权级更高的级别,发生栈切换.
   1. 从当前task 的TSS 获取中断处理代码的 segment selector 和 stack pointer. 在这个新栈上,处理器把被中断的 procedure 的 stack segment selector 和 stack pointer 入栈.
   2. 处理器保存当前的EFLAGS CS EIP 到新栈上.
2. 如果发生在同一特权级别,就在当前栈上保存 EFLAGS,CS,EIP.如果异常导致要保存一个错误码,就再压入 EIP.

要从中断 precedure 返回,handler 必须使用`IRET`指令. 此指令与`RET`类似,except that 此指令把保存下来的 flag 恢复到 EFLAGS.

if a stack switch occured when calling the handler ppreocedure, IRET 指令 switch back 到被中断的栈.

IRET: 用于从中断处理流程返回至被中断的代码.


对于中断或陷阱门:

![](/images/Interrupt&#32;Procedure&#32;Call.jpg)

对于任务切换门:

![](/images/Interrupt&#32;Task&#32;Switch.jpg)

## 7.1 任务管理

一个任务可以是一组任务,处理器可以**分发**,**执行**,和**暂停**它们.任务可以用于执行程序,或者另外一个任务,或者是操作系统工具,中断异常处理器,或者是内核或可执行应用程序.

IA32 架构提供了一种机制,这种机制可以用于保存任务状态,用于